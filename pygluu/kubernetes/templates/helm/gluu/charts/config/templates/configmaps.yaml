# License terms and conditions for Gluu Cloud Native Edition:
# https://www.apache.org/licenses/LICENSE-2.0
apiVersion: v1
kind: ConfigMap
metadata: 
  name: {{ .Release.Name }}-config-cm
  namespace: {{ .Release.Namespace }}
data:
  CLOUD_NATIVE_CONFIG_ADAPTER: {{ .Values.configmap.configAdapterName }}
  CLOUD_NATIVE_SECRET_ADAPTER: {{ .Values.configmap.configSecretAdapter }}
  CLOUD_NATIVE_CONFIG_KUBERNETES_NAMESPACE: {{ .Release.Namespace | quote }}
  CLOUD_NATIVE_SECRET_KUBERNETES_NAMESPACE: {{ .Release.Namespace | quote }}
  CLOUD_NATIVE_CONTAINER_METADATA: {{ .Values.configmap.containerMetadataName | quote }}
  CLOUD_NATIVE_MAX_RAM_PERCENTAGE: {{ .Values.configmap.gluuMaxRamPercent | quote }}
  CLOUD_NATIVE_CACHE_TYPE: {{ .Values.configmap.gluuCacheType | quote }}
  CLOUD_NATIVE_DOCUMENT_STORE_TYPE: {{ .Values.configmap.gluuDocumentStoreType | quote }}
  CLOUD_NATIVE_JACKRABBIT_SYNC_INTERVAL: {{ .Values.configmap.gluuJackrabbitSyncInterval | quote }}
  CLOUD_NATIVE_JACKRABBIT_URL: {{ .Values.configmap.gluuJackrabbitUrl | quote }}
  DOMAIN: {{ .Values.global.domain | quote }}
  CLOUD_NATIVE_AUTH_SERVER_BACKEND: {{ .Values.configmap.gluuAuthServerBackend | quote }}
  CLOUD_NATIVE_CLIENT_API_SERVER_URL: {{ .Values.configmap.jansClientApiServerUrl | quote }}
  CLOUD_NATIVE_CLIENT_API_BIND_IP_ADDRESSES: {{ .Values.configmap.jansClientApiBindIpAddresses | quote }}
  {{- if and (eq .Values.global.isDomainRegistered "false") (or (eq .Values.global.provisioner "kubernetes.io/aws-ebs") (eq .Values.global.provisioner "openebs.io/local")) }}
  LB_ADDR: {{ .Values.configmap.lbAddr }}
  {{- end }}
  CLOUD_NATIVE_PERSISTENCE_TYPE: {{ .Values.global.gluuPersistenceType }}
  {{- if or (eq .Values.global.gluuPersistenceType "ldap") (eq .Values.global.gluuPersistenceType "hybrid")  }}
  # used only if CLOUD_NATIVE_PERSISTENCE_TYPE is ldap or hybrid
  CLOUD_NATIVE_LDAP_URL: {{ .Values.configmap.gluuLdapUrl | quote }}
  {{- else if or (eq .Values.global.gluuPersistenceType "couchbase") (eq .Values.global.gluuPersistenceType "hybrid") }}
  #  used only if CLOUD_NATIVE_PERSISTENCE_TYPE is couchbase or hybrid
  CLOUD_NATIVE_COUCHBASE_URL: {{ .Values.configmap.gluuCouchbaseUrl }}
  CLOUD_NATIVE_COUCHBASE_USER: {{ .Values.configmap.gluuCouchbaseUser }}
  CLOUD_NATIVE_COUCHBASE_CERT_FILE: {{ .Values.configmap.gluuCouchbaseCertFile | quote }}
  CLOUD_NATIVE_COUCHBASE_PASSWORD_FILE: {{ .Values.configmap.gluuCouchbasePassFile | quote }}
  CLOUD_NATIVE_COUCHBASE_SUPERUSER: {{ .Values.configmap.gluuCouchbaseSuperUser }}
  CLOUD_NATIVE_COUCHBASE_SUPERUSER_PASSWORD_FILE: {{ .Values.configmap.gluuCouchbaseSuperUserPassFile | quote }}
  {{- end }}
  CLOUD_NATIVE_KEY_ROTATION_FORCE: "false"
  CLOUD_NATIVE_KEY_ROTATION_CHECK: "3600"
  CLOUD_NATIVE_KEY_ROTATION_INTERVAL: "48"
  CLOUD_NATIVE_SSL_CERT_FROM_SECRETS: "true"
  # options: default/user/site/cache/statistic used only if CLOUD_NATIVE_PERSISTENCE_TYPE is hybrid or hybrid
  {{- if or (eq .Values.global.gluuPersistenceType "hybrid") (eq .Values.global.gluuPersistenceType "ldap") }}
  CLOUD_NATIVE_PERSISTENCE_LDAP_MAPPING: {{ .Values.configmap.gluuPersistenceLdapMapping | quote }}
  {{- end }}
  CLOUD_NATIVE_LDAP_INIT_HOST: {{ .Values.configmap.ldapServiceName }} #{{ template "gluu.fullname" . }}-service
  CLOUD_NATIVE_LDAP_INIT: {{ .Values.gluuLdapInit | quote }} # TODO: To be removed
  CLOUD_NATIVE_LDAP_INIT_PORT: {{ .Values.gluuLdapInitPort | quote }}
  CLOUD_NATIVE_OXTRUST_CONFIG_GENERATION: {{ .Values.gluuOxtrustConfigGeneration | quote }}
  # must the same as the opendj service name
  CLOUD_NATIVE_CERT_ALT_NAME: {{ .Values.configmap.ldapServiceName }} #{{ template "gluu.fullname" . }}-service
  CLOUD_NATIVE_SYNC_CASA_MANIFESTS: {{ .Values.configmap.gluuSyncCasaManifests | quote }}
  CLOUD_NATIVE_OXTRUST_BACKEND: {{ .Values.configmap.gluuOxtrustBackend | quote }}
  CLOUD_NATIVE_SYNC_SHIB_MANIFESTS: {{ .Values.configmap.gluuSyncShibManifests | quote }}
  CLOUD_NATIVE_OXTRUST_API_ENABLED: {{ .Values.configmap.gluuOxtrustApiEnabled | quote }}
  CLOUD_NATIVE_OXTRUST_API_TEST_MODE: {{ .Values.configmap.gluuOxtrustApiTestMode | quote }}
  {{ if eq .Values.global.gluuJackrabbitCluster "true" }}
  CLOUD_NATIVE_JACKRABBIT_ADMIN_ID: {{ .Values.configmap.gluuJackrabbitAdminId | quote }}
  CLOUD_NATIVE_JACKRABBIT_ADMIN_PASSWORD_FILE: {{ .Values.configmap.gluuJackrabbitAdminPassFile | quote }}
  CLOUD_NATIVE_JACKRABBIT_CLUSTER: {{ .Values.global.gluuJackrabbitCluster | quote }}
  CLOUD_NATIVE_JACKRABBIT_POSTGRES_USER: {{ .Values.configmap.gluuJackrabbitPostgresUser | quote }}
  CLOUD_NATIVE_JACKRABBIT_POSTGRES_PASSWORD_FILE: {{ .Values.configmap.gluuJackrabbitPostgresPasswordFile | quote }}
  CLOUD_NATIVE_JACKRABBIT_POSTGRES_HOST: {{ .Values.configmap.gluuJackrabbitPostgresHost | quote }}
  CLOUD_NATIVE_JACKRABBIT_POSTGRES_PORT: {{ .Values.configmap.gluuJackrabbitPostgresPort | quote }}
  CLOUD_NATIVE_JACKRABBIT_POSTGRES_DATABASE: {{ .Values.configmap.gluuJackrabbitPostgresDatabaseName | quote }}
  # CLOUD_NATIVE_JACKRABBIT_PASSWORD_FILE: {{ .Values.configmap.gluuJcaPasswordFile | quote }} NOT IMPLEMENTED
  {{- end }}
  # Auto enable installation of some services
  CLOUD_NATIVE_CASA_ENABLED: {{ .Values.configmap.gluuCasaEnabled | quote }}
  CLOUD_NATIVE_PASSPORT_ENABLED: {{ .Values.configmap.gluuPassportEnabled | quote }}
  CLOUD_NATIVE_RADIUS_ENABLED: {{ .Values.configmap.gluuRadiusEnabled | quote }}
  {{- if .Values.global.oxshibboleth.enabled }}
  CLOUD_NATIVE_SAML_ENABLED: {{ .Values.configmap.gluuSamlEnabled | quote }}
  {{- end }}
  CLOUD_NATIVE_CLIENT_API_APPLICATION_CERT_CN: {{ .Values.configmap.jansClientApiApplicationCertCn | quote }}
  CLOUD_NATIVE_CLIENT_API_ADMIN_CERT_CN: {{ .Values.configmap.jansClientApiAdminCertCn | quote }}
  {{ if eq .Values.configmap.gluuCacheType "REDIS" }}
  CLOUD_NATIVE_REDIS_URL: {{ .Values.configmap.gluuRedisUrl | quote }}
  CLOUD_NATIVE_REDIS_TYPE: {{ .Values.configmap.gluuRedisType | quote }}
  CLOUD_NATIVE_REDIS_USE_SSL: {{ .Values.configmap.gluuRedisUseSsl | quote }}
  CLOUD_NATIVE_REDIS_SSL_TRUSTSTORE: {{ .Values.configmap.gluuRedisSslTruststore | quote }}
  CLOUD_NATIVE_REDIS_SENTINEL_GROUP: {{ .Values.configmap.gluuRedisSentinelGroup | quote }}
  {{- end }}

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "config.fullname" . }}-gen-json-file
  namespace: {{ .Release.Namespace }}
data:
  generate.json: |-
    {
      "hostname": {{ .Values.global.domain | quote }},
      "country_code": {{ .Values.countryCode | quote }},
      "state": {{ .Values.state | quote }},
      "city": {{ .Values.city | quote }},
      "admin_pw": {{ .Values.adminPass | quote }},
      "ldap_pw": {{ .Values.ldapPass | quote }},
      "redis_pw": {{ .Values.redisPass | quote }},
      "email": {{ .Values.email | quote }},
      "org_name": {{ .Values.orgName | quote }}
    }

---

apiVersion: v1
data:
  tls_generator.py: |-
    from pprint import pprint
    from kubernetes import config, client
    import logging

    #use the serviceAccount k8s gives to pods
    config.load_incluster_config()
    v1 = client.CoreV1Api()

    #global vars
    name = "tls-certificate"
    namespace = {{ .Release.Namespace | quote }}

    # if istio is enabled
    istio_ns = {{ .Values.global.istio.namespace | quote }}

    # create cert in istio-system
    def create_tls_in_istio(cert, key):

        v1 = client.CoreV1Api()
        try:
            secret = v1.read_namespaced_secret(name, istio_ns)
        except client.rest.ApiException as e:
            if e.status == 404:
                print('secret/{} in ns/{} does not exist. Creating...'.format(
                    name, istio_ns))
                metadata = {
                    'name': name,
                    'namespace': istio_ns
                }
                data = {
                    'tls.crt': cert,
                    'tls.key' : key,
                }
                api_version = 'v1'
                kind = 'Secret'
                body = client.V1Secret(api_version, data , kind, metadata,
                    type='kubernetes.io/tls')
                api_response = v1.create_namespaced_secret(istio_ns, body )
            else:
                logging.exception(e)
            return False
        else:
            print('tls-certificate already exists.')


    # check if gluu secret exists
    def get_certs():
        if ( v1.read_namespaced_secret( 'gluu', namespace ) ):
            ssl_cert = v1.read_namespaced_secret( 'gluu', namespace ).data['ssl_cert']
            ssl_key = v1.read_namespaced_secret( "gluu", namespace ).data['ssl_key']

        return ssl_cert, ssl_key

    def create_tls(cert, key):

        v1 = client.CoreV1Api()
        try:
            secret = v1.read_namespaced_secret(name, namespace)
        except client.rest.ApiException as e:
            if e.status == 404:
                print('secret/{} in ns/{} does not exist. Creating...'.format(
                    name, namespace))
                metadata = {
                    'name': name,
                    'namespace': namespace
                }
                data = {
                    'tls.crt': cert,
                    'tls.key' : key,
                }
                api_version = 'v1'
                kind = 'Secret'
                body = client.V1Secret(api_version, data , kind, metadata,
                    type='kubernetes.io/tls')
                api_response = v1.create_namespaced_secret(namespace, body )
            else:
                logging.exception(e)
            return False
        else:
            print('tls-certificate already exists.')

    def main():
        cert, key = get_certs()
        create_tls(cert, key)

        # create or check cert if istio is enabled
        {{- if .Values.global.istio.ingress }}
        create_tls_in_istio(cert, key)
        {{- end }}

    if __name__ == "__main__":
        main()

kind: ConfigMap
metadata:
  name: {{ include "config.fullname" . }}-tls-script
  namespace: {{ .Release.Namespace }}

---

apiVersion: v1
data:
  updatelbip.py: |-
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

    # Update the IP of the load balancer automatically

    """
     License terms and conditions for Gluu Cloud Native Edition:
     https://www.apache.org/licenses/LICENSE-2.0
    """

    import socket
    import os
    import logging
    import time

    logger = logging.getLogger("update-lb-ip")
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    fmt = logging.Formatter('%(levelname)s - %(asctime)s - %(message)s')
    ch.setFormatter(fmt)
    logger.addHandler(ch)


    def backup(hosts):
        timenow = time.strftime("%c")
        timestamp = "Backup occurred %s \n" % timenow
        logger.info("Backing up hosts file to /etc/hosts.back ...")
        with open('/etc/hosts.back', 'a+') as f:
            f.write(timestamp)
            for line in hosts:
                f.write(line)


    def get_hosts(lb_addr, domain):
        ip_list = []
        hosts_list = []
        ais = socket.getaddrinfo(lb_addr, 0, 0, 0, 0)
        for result in ais:
            ip_list.append(result[-1][0])
        ip_list = list(set(ip_list))
        for ip in ip_list:
            add_host = ip + " " + domain
            hosts_list.append(add_host)

        return hosts_list


    def main():
        try:
            while True:
                lb_addr = os.environ.get("LB_ADDR", "")
                domain = os.environ.get("DOMAIN", "demoexample.gluu.org")
                host_file = open('/etc/hosts', 'r').readlines()
                hosts = get_hosts(lb_addr, domain)
                stop = []
                for host in hosts:
                    for i in host_file:
                        if host.replace(" ", "") in i.replace(" ", ""):
                            stop.append("found")
                if len(stop) != len(hosts):
                    backup(host_file)
                    logger.info("Writing new hosts file")
                    with open('/etc/hosts', 'w') as f:
                        for line in host_file:
                            if domain not in line:
                                f.write(line)
                        for host in hosts:
                            f.write(host)
                            f.write("\n")
                        f.write("\n")
                time.sleep(300)
        except KeyboardInterrupt:
            logger.warning("Canceled by user; exiting ...")


    if __name__ == "__main__":
        main()

kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-updatelbip
  namespace: {{ .Release.Namespace }}
